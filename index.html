<script id="IOC_TAIL_SYNC">
(function(){
  function upd(j){
    var c=+j.current||0,t=+j.target||0;if(t<c)t=c;
    var p=t?Math.min(100,Math.round(c*100/t)):0;
    if(typeof window.setSync==="function"){
      if(p<100){window.setSync(p,"Syncing wallet ("+c+" / "+t+" blocks)");}
      else{window.setSync(100,"Wallet is up to date");}
    }else{
      var el=document.getElementById("syncText")||[...document.querySelectorAll("*")].find(n=>/Syncing wallet/i.test(n.textContent||""));
      if(el) el.textContent=p<100?("Syncing wallet ("+c+" / "+t+" blocks)"):"Wallet is up to date";
      var bar=document.getElementById("syncbar"); if(bar) bar.style.width=p+"%";
    }
  }
  function tick(){fetch("http://127.0.0.1:17334/sync",{cache:"no-store"}).then(r=>r.json()).then(upd).catch(()=>{});}
  setInterval(tick,1000); tick();
})();
</script>
<script id="IOC_TAIL_STABLE">
(function(){
  var lastC=0,lastT=0,lastDraw=0, pending=null;
  function apply(c,t){
    // enforce monotonicity on the client, too
    if(c<lastC) c=lastC;
    if(t<lastT) t=lastT;
    if(t<c) t=c;
    lastC=c; lastT=t;

    var p = t ? Math.min(100, Math.round(c*100/t)) : 0;

    // draw at most every 300ms
    pending = {p:p,c:c,t:t};
    var now = performance.now();
    if(now-lastDraw<300) return;
    lastDraw = now;

    requestAnimationFrame(function(){
      var d=pending; pending=null;
      if(typeof window.setSync==="function"){
        if(d.p<100){ window.setSync(d.p, "Syncing wallet ("+d.c+" / "+d.t+" blocks)"); }
        else{ window.setSync(100, "Wallet is up to date"); }
      }else{
        var el=document.getElementById("syncText")||[...document.querySelectorAll("*")].find(n=>/Syncing wallet/i.test(n.textContent||""));
        if(el) el.textContent = d.p<100 ? ("Syncing wallet ("+d.c+" / "+d.t+" blocks)") : "Wallet is up to date";
        var bar=document.getElementById("syncbar"); if(bar) bar.style.width = d.p + "%";
      }
    });
  }
  function tick(){
    fetch("http://127.0.0.1:17334/sync",{cache:"no-store"})
      .then(r=>r.json())
      .then(j=>{
        var c=+j.current||0, t=+j.target||0;
        // if server briefly restarts (0/0), ignore
        if(c===0 && t===0 && (lastC>0 || lastT>0)) return;
        apply(c,t);
      })
      .catch(function(){ /* ignore transient errors */ });
  }
  setInterval(tick, 1000);
  tick();
})();
</script>
<script id="IOC_TAIL_CLIENT">
(function(){
  var lastC=0,lastT=0;
  function apply(c,t){
    if(c<lastC)c=lastC; if(t<lastT)t=lastT; if(t<c)t=c;
    lastC=c; lastT=t;
    var p=t?Math.round(c*100/t):0;
    if(typeof window.setSync==="function"){
      if(p<100)window.setSync(p,"Syncing wallet ("+c+" / "+t+" blocks)");
      else window.setSync(100,"Wallet is up to date");
    }else{
      var el=document.getElementById("syncText")||[...document.querySelectorAll("*")].find(n=>/Syncing wallet/i.test(n.textContent||""));
      if(el)el.textContent=p<100?("Syncing wallet ("+c+" / "+t+" blocks)"):"Wallet is up to date";
      var bar=document.getElementById("syncbar");if(bar)bar.style.width=p+"%";
    }
  }
  function tick(){
    fetch("http://127.0.0.1:17334/sync",{cache:"no-store"}).then(r=>r.json()).then(j=>{
      var c=+j.current||0,t=+j.target||0;
      if(c===0&&t===0&&(lastC||lastT))return; // ignore bogus
      apply(c,t);
    }).catch(()=>{});
  }
  setInterval(tick,1000);tick();
})();
</script>
<script id="IOC_TAIL_CLIENT_V2">
(function(){
  var lastC=0,lastT=0,lastDraw=0,pending=null,haveReal=false;
  function draw(p,c,t){
    var api=window.setSync;
    if(!haveReal){
      if(typeof api==="function"){ api(0,"Syncing wallet…"); }
      else{
        var el=document.getElementById("syncText")||[...document.querySelectorAll("*")].find(n=>/Syncing wallet/i.test(n.textContent||""));
        if(el) el.textContent="Syncing wallet…";
      }
      return;
    }
    if(typeof api==="function"){
      if(p<100) api(p,"Syncing wallet ("+c+" / "+t+" blocks)");
      else api(100,"Wallet is up to date");
    }else{
      var el=document.getElementById("syncText")||[...document.querySelectorAll("*")].find(n=>/Syncing wallet/i.test(n.textContent||""));
      if(el) el.textContent = p<100 ? ("Syncing wallet ("+c+" / "+t+" blocks)") : "Wallet is up to date";
      var bar=document.getElementById("syncbar"); if(bar) bar.style.width=p+"%";
    }
  }
  function apply(c,t){
    if(c>0||t>0) haveReal=true;
    if(c<lastC) c=lastC;
    if(t<lastT) t=lastT;
    if(t<c) t=c;
    lastC=c; lastT=t;
    var p = t ? Math.min(100,Math.round(c*100/t)) : 0;
    pending={p:p,c:c,t:t};
    var now=performance.now();
    if(now-lastDraw<250) return;
    lastDraw=now;
    requestAnimationFrame(function(){var d=pending||{p:p,c:c,t:t}; pending=null; draw(d.p,d.c,d.t);});
  }
  function tick(){
    fetch("http://127.0.0.1:17334/sync",{cache:"no-store"})
      .then(r=>r.json())
      .then(j=>{
        var c=+j.current||0, t=+j.target||0;
        if(!haveReal && c===0 && t===0) { draw(0,0,0); return; }
        apply(c,t);
      })
      .catch(function(){ /* keep last stable state */ });
  }
  setInterval(tick,1000); tick();
})();
</script>
<script id="IOC_TAIL_CLIENT_V3">
(function(){
  var lastC=0,lastT=0,lastDraw=0,pending=null,ready=false;
  function draw(p,c,t){
    var api=window.setSync;
    if(!ready){
      if(typeof api==="function"){ api(0,"Syncing wallet…"); }
      else{
        var el=document.getElementById("syncText")||[...document.querySelectorAll("*")].find(n=>/Syncing wallet/i.test(n.textContent||""));
        if(el) el.textContent="Syncing wallet…";
      }
      return;
    }
    if(typeof api==="function"){
      if(p<100) api(p,"Syncing wallet ("+c+" / "+t+" blocks)");
      else api(100,"Wallet is up to date");
    }else{
      var el=document.getElementById("syncText")||[...document.querySelectorAll("*")].find(n=>/Syncing wallet/i.test(n.textContent||""));
      if(el) el.textContent=p<100?("Syncing wallet ("+c+" / "+t+" blocks)"):"Wallet is up to date";
      var bar=document.getElementById("syncbar"); if(bar) bar.style.width=p+"%";
    }
  }
  function apply(c,t){
    if(c>0 && t>0) ready=true;              // only show numbers when both are real
    if(c<lastC) c=lastC;
    if(t<lastT) t=lastT;
    if(t<c) t=c;
    lastC=c; lastT=t;
    var p = t ? Math.min(100,Math.round(c*100/t)) : 0;
    pending={p:p,c:c,t:t};
    var now=performance.now();
    if(now-lastDraw<250) return;
    lastDraw=now;
    requestAnimationFrame(function(){var d=pending||{p:p,c:c,t:t}; pending=null; draw(d.p,d.c,d.t);});
  }
  function tick(){
    fetch("http://127.0.0.1:17334/sync",{cache:"no-store"})
      .then(r=>r.json())
      .then(j=>{
        var c=+j.current||0,t=+j.target||0;
        if(!ready && (c===0 || t===0)){ draw(0,0,0); return; } // keep plain "Syncing wallet…"
        apply(c,t);
      })
      .catch(function(){ /* keep last stable state */ });
  }
  setInterval(tick,1000); tick();
})();
</script>
